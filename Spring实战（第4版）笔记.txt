一、
001、用magic测试

第2章、装配bean
001、在需要自动装配的地方用@Autowired注解。
002、将@Autowired的required属性设置为false，则在没有匹配的bean时也不会异常。
003、如果有多个bean都能满足依赖关系的话，Spring将会抛出一个异常，表明没有明确指定要选择哪个bean进行自动装
004、@Inject和@Autowire注解在很多情况下可以互换。
005、@Component声明当前类是一个Spring组件。
006、@ComponentScan启用组件扫描,自动扫描带有被@Component注解的类，并为其创建bean(相当于xml配置中的<context:component-scan>)
007、@Configuration表明当前类是配置类。
008、JavaConfig类中，在方法前添加@Bean注解，则这个方法将会返回一个对象，该对象要注册为Spring应用上下文中的bean。
009、基于XML的Spring配置中的<bean>相当于JavaConfig中的@Bean注解。
010、@ComponentScan可以设置扫描包@ComponentScan("package")或@ComponentScan(basePackages={"package","package"})
011、@Autowired注解可以用在类的任何方法或者属性上
012、带有@Bean注解的方法可以采用任何必要的Java功能来产生bean实例
013、@Import注解可以导入其它javaConfig配置（如：@Import({myConfig.class，yourConfig.class})）
014、@ImportResource注解可以载javaConfig配置中加入其他XML配置

第3章、高级装配
001、不管是JavaConfig或者是XML配置，都可以通过profile配置来根据环境（开发、测试、生产）来选择则配置。
002、Spring在确定哪个profile处于激活状态时，需要依赖两个独立的属性：spring.profiles.active和spring.profiles.default。
003、有多种方式来设置spring.profiles.active和spring.profiles.default这两个属性：a、作为DispatcherServlet的初始化参数；b、作为Web应用的上下文参数；c、作为JNDI条目；d、作为环境变量；e、作为JVM的系统属性；6、在集成测试类上，使用@ActiveProfiles注解设置。
004、spring4可以通过@Conditional注解来根据条件确定创建bean。
005、当存在多个类同时实现了同一个接口时，Spring便不能够知道应该用哪个bean，此时可以用@Primary注解其中一个类作为首选bean。（若用xml配置，则@Primary和@Component组合使用，若用JavaConfig配置，则@Primary和@bean组合使用）。（不推荐）
006、@Qualifier注解是使用限定符的主要方式。它可以与@Autowired和@Inject协同使用，在注入的时候指定想要注入进去的是哪个bean
007、防止spring注入歧义的方法：们可以创建自定义的限定符注解，借助这样的注解来表达bean所希望限定的特性
008、单例是默认的作用域
009、javaConfig如果选择其他的作用域，要使用@Scope注解，它可以与@Component或@Bean一起使用;
010、XML配置，<aop:scoped-proxy>选择其他的作用域（要在XML配置中声明Spring的aop命名空间）
011、pring定义了多种作用域：单例（Singleton）、原型（Prototype）、会话（Session）、请求（Rquest）。
012、有时候要在类中获取配置文件中的值，可以避免硬性编码：1、javaConfig使用@PropertySource注解和Environment。2、通过占位符装配属性的方法。

第4章、面向切面
001、在软件开发中，散布于应用中多处的功能被称为横切关注点（crosscutting concern）
002、DI(依赖注入)的作用：有助于应用对象之间的解耦；AOP（面向切面）可以实现横切关注点与它们所影响的对象之间的解耦。
003、切面：横切关注点可以被模块化为特殊的类，这些类被称为切面（aspect）。
004、通知：切面的工作被称为通知（Advice）。
005、通知定义了切面是什么以及何时使用。除了描述切面要完成的工作，通知还解决了何时执行这个工作的问题。它应该应用在某个方法被调用之前？之后？之前和之后都调用？还是只在方法抛出异常时调用？
006、Spring切面可以应用5种类型的通知：前置通知（Before）、后置通知（After）、返回通知（After-returning）、异常通知（After-throwing）、环绕通知（Around）
007、连接点（Join point）：应用可能有数以千计的时机应用通知，这些时机被称为连接点（Join point）。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时
008、切点（Poincut）：切点的定义会匹配通知所要织入的一个或多个连接点
009、切面（Aspect）：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容――它是什么，在何时和何处完成其功能。
010、引入（Introduction）：引入允许我们向现有的类添加新方法或属性。
011、织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。
012、在目标对象的生命周期里有多个点可以进行织入：编译期、类加载期、运行期（Spring AOP就是以这种方式织入切面的）
013、通知包含了需要用于多个应用对象的横切行为；连接点
014、是程序执行过程中能够应用通知的所有点；切点定义了通知被应用的具体位置（在哪些连接点）。其中关键的概念是切点定义了哪些连接点会得到通知。
015、创建切点来定义切面所织入的连接点是AOP框架的基本功能。
016、Spring只支持方法级别的连接点。
017、切点用于准确定位应该在什么地方应用切面的通知
018、只有execution指示器是实际执行匹配的，而其他的指示器都是用来限制匹配的。
019、用@AspectJ注解表明被标注的类不仅仅是一个POJO，还是一个切面。
020、@Pointcut注解能够在一个@AspectJ切面内定义可重用的切点
021、如果使用JavaConfig的话，可以在配置类的类级别上通过使用EnableAspectJ-AutoProxy注解启用自动代理功能
022、假如在Spring中要使用XML来装配bean的话，那么需要使用Springaop命名空间中的<aop:aspectj-autoproxy>元素启用自动代理功能
023、环绕通知（@Around）必须接收ProceedingJoinPoint作为参数，对象是必须要有的，因为你要在通知中通过它来调用被通知的方法。通知方法中可以做任何的事情，当要将控制权交给被通知的方法时，它需要调用ProceedingJoinPoint的proceed()方法

第5章、构建Spring Web应用程序
001、在Spring MVC中，DispatcherServlet就是前端控制器。DispatcherServlet是Spring MVC的核心
002、DispatcherServlet是单实例的Servlet。
003、请求先到Spring的DispatcherServlet，DispatcherServlet的任务是将请求发送给Spring MVC控制器（controller），控制器是一个用于处理请求的Spring组件。在典型的应用程序中可能会有多个控制器，
     DispatcherServlet以会查询一个或多个处理器映射（handler mapping） 来确定请求的下一站在哪里，然后DispatcherServlet会将请求发送给这个控制器，到了控制器，请求会卸下其负载（用户提交的
	 信息）并耐心等待控制器处理这些信息。（实际上，设计良好的控制器本身只处理很少甚至不处理工作，而是将业务逻辑委托给一个或多个服务对象进行处理。）控制器在完成逻辑处理后，通常会产生一
	 些信息，这些信息需要返回给用户并在浏览器上显示。这些信息被称为模型（model）。不过仅仅给用户返回原始的信息是不够的――这些信息需要以用户友好的方式进行格式化，一般会是HTML。所以，信
	 息需要发送给一个视图（view），通常会是JSP。控制器所做的最后一件事就是将模型数据打包，并且标示出用于渲染输出的视图名。它接下来会将请求连同模型和视图名发送回DispatcherServlet 。这
	 样，控制器就不会与特定的视图相耦合，传递给DispatcherServlet的视图名并不直接表示某个特定的JSP。实际上，它甚至并不能确定视图就是JSP。相反，它仅仅传递了一个逻辑名称，这个名字将会用
	 来查找产生结果的真正视图。DispatcherServlet将会使用视图解析器（view resolver）来将逻辑视图名匹配为一个特定的视图实现，它可能是也可能不是JSP。它的最后一站是视图的实现（可能是JSP）
	 ，在这里它交付模型数据。请求的任务就完成了。视图将使用模型数据渲染输出，这个输出会通过响应对象传递给客户端（不会像听上去那样硬编码） 。
004、DispatcherServlet配置的方法：1、配置在web.xml文件中；2、用Java将DispatcherServlet配置在Servlet容器中（只能部署到支持Servlet 3.0的服务器）。
005、扩展AbstractAnnotationConfigDispatcherServletInitializer的任意类都会自动地配置Dispatcher-Servlet和Spring应用上下文，Spring的应用上下文会位于应用程序的Servlet上下文之中。
006、DispatcherServlet加载包含Web组件的bean，如控制器、视图解析器以及处理器映射，而ContextLoaderListener要加载应用中的其他bean。这些bean通常是驱动应用后端的中间层和数据层组件。
007、AbstractAnnotationConfigDispatcherServletInitializer会同时创建DispatcherServlet和ContextLoaderListener。GetServletConfigClasses()方法返回的带有@Configuration注解的类将会用来定义
     DispatcherServlet应用上下文中的bean。getRootConfigClasses()方法返回的带有@Configuration注解的类将会用来配置ContextLoaderListener创建的应用上下文中的bean。
008、启用Spring MVC组件的方法：1、<mvc:annotation-driven>；2、用有@EnableWebMvc注解javaConfig配置类。
009、WebConfig添加了@ComponentScan注解：会使带有@Controller注解的控制器成为组件扫描时的候选bean。
010、试图解释器InternalResourceViewResolver：在查找的时候，它会在视图名称上加一个特定的前缀和后缀（例如，名为home的视图将会解析为/WEB-INF/views/home.jsp）。
011、要求DispatcherServlet将对静态资源的请求转发到Servlet容器中默认的Servlet上，而不是使用DispatcherServlet本身来处理此类请求：javaConfig扩展WebMvcConfigurerAdapter并重写了
     其configureDefaultServletHandling()方法。通过调用DefaultServlet-HandlerConfigurer的enable()方法
012、用@ComponentScan注解RootConfig，这样的话，我们就有很多机会用非Web的组件来充实完善RootConfig。
013、在Spring MVC中，控制器只是方法上添加了@RequestMapping注解的类，这个注解声明了它们所要处理的请求。
014、可以用@Controller也可以用@Component注解Controller类，但有@Component无法确定这个类是什么组件类型。
015、MockMvc可以不用启动服务器和浏览器测试springmvc。
016、@RequestMapping的value属性能够接受一个String类型的数组。
017、Model实际上就是一个Map（也就是key-value对的集合），它会传递给视图，这样数据就能渲染到客户端了。当调用addAttribute()方法并且不指定key的时候，那么key会根据值的对象类型推断确定。
018、可以用java.util.Map来代替Model。
019、Spring MVC允许以多种方式将客户端中的数据传送到控制器的处理器方法中，包括：查询参数（Query Parameter）、表单参数（Form Parameter）、路径变量（Path Variable）。
020、接收参数的形式：a、“/spittles/show?spittle_id=12345”；b、“/spittles/12345”
021、@PathVariable("spittleId")注解，这表明在请求路径中，不管占位符部分的值是什么都会传递到处理器方法的spittleId参数中
022、springMVC允许我们在@RequestMapping路径中添加占位符。占位符的名称要用大括号（“{”和“}”）括起来
022、“redirect:”前缀--重定向到指定的URL路径；
023、“forward:”前缀--前往到指定的URL路径
024、spring可以在参数对象的属性上面添加注解来对字段进行校验。另外，在Controller中BindingResult参数要紧跟在带有@Validated注解的参数后面，@Validated注解所标注的就是要检验的参数。
025、主要关注的视图解释器：InternalResourceViewResolver，它遵循一种约定，会在视图名上添加前缀和后缀，进而确定一个Web应用中视图资源的物理路径。


第7章、Spring MVC的高级技术
001、在典型的Spring MVC应用中，我们会需要DispatcherServlet和ContextLoaderListener（为避免复杂化，通常只用一个DispatcherServlet上下文就可以了，不用ContextLoaderListener那个）。
002、文件上传:multipart格式的数据会将一个表单拆分为多个部分（part），每个部分对应一个输入域
003、文件上传:在编写控制器方法处理文件上传之前，我们必须要配置一个multipart解析器，通过它来告诉DispatcherServlet该如何读取multipart请求。
004、文件上传:MultipartResolver的实现，可选择其中一个：a、CommonsMultipartResolver：使用Jakarta CommonsFileUpload解析multipart请求；b、StandardServletMultipartResolver：依赖于Servlet 3.0对multipart请求的支持（始于Spring 3.1）。
005、文件上传:StandardServletMultipartResolver：可以在servlet中设置整个multipart请求的最大容量、上传文件的最大容量、临时文件路径、最大的内存大小（超过多少就会写到临时文件夹）（推荐）
006、文件上传:CommonsMultipartResolver：可以设置临时文件路径、最大的文件容量、最大的内存大小（超过多少就会写到临时文件夹）（替代方案）
007、文件上传:<form>标签现在将enctype属性设置为multipart/formdata，在multipart中，每个输入域都会对应一个part
008、文件上传:<input>域，其type为file。这能够让用户选择要上传的图片文件。accept属性用来将文件类型限制为JPEG、PNG以及GIF图片
009、文件上传:方式一是Controller的方法添加byte数组参数接收文件，并为其添加@RequestPart注解
010、文件上传:方式二是MultipartFile（可以是数组）接受，MultipartFile接口可以处理multipart数据的内容（可以满足文件的一般处理需求）。
011、文件上传:保存文件到云端，可以将文件保存到Amazon S3中
012、文件上传:方式三是Part的形式接受上传的文件
013、文件上传:通过Part参数的形式接受文件上传，那么就没有必要配置MultipartResolver了。只有使用MultipartFile的时候，我们才需要MultipartResolver。
014、Spring提供了多种方式将异常转换为响应：特定的Spring异常将会自动映射为指定的HTTP状态码；异常上可以添加@ResponseStatus注解，从而将其映射为某一个HTTP状态码；在方法上可以添加@ExceptionHandler注解，使其用来处理异常。
015、在控制器添加一个处理异常的方法，并为改方法添加@ExceptionHandler注解，这样的话当这个控制器的任何一个方法抛出@ExceptionHandler指定的异常的时候，将会委托该方法来处理。（可以在控制器的公用父类添加这个方法）
016、控制器通知（controller advice）是任意带有@ControllerAdvice注解的类，这个类会包含一个或多个如下类型的方法：@ExceptionHandler注解标注的方法；@InitBinder注解标注的方法；@ModelAttribute注解标注的方法。
017、在带有@ControllerAdvice注解的类中，以上所述的这些方法会运用到整个应用程序所有控制器中带有@RequestMapping注解的方法上。
018、@ControllerAdvice注解本身已经使用了@Component，因此@ControllerAdvice注解所标注的类将会自动被组件扫描获取到，就像带有@Component注解的类一样
019、@ExceptionHandler()的参数填写的异常类就是这个方法要捕获和处理的异常
020、可以在控制器或者是控制器的处理方法中添加@ResponseBody注解，表示返回的是字符串，而不是发起的请求。


第9章、保护Web应用
001、Spring Security是一种基于Spring AOP和Servlet规范中的Filter实现的安全框架
002、Spring Security提供了完整的安全性解决方案，它能够在Web请求级别和方法调用级别处理身份认证和授权
003、DelegatingFilterProxy把Filter的处理逻辑委托给Spring应用上下文中所定义的一个代理Filter bean；
004、可以在web.xml中配置过滤器DelegatingFilterProxy，但是<filter-name>设置成springSecurityFilterChain
005、不管我们通过web.xml还是通过AbstractSecurityWebApplicationInitializer的子类来配置DelegatingFilterProxy，它都会拦截发往应用中的请求，并将请求委托给ID为springSecurityFilterChain bean。
006、如果用java配置文件配置，@EnableWebSecurity或@EnableWebMvcSecurity注解将会启用Web安全功能，Spring Security必须配置在一个实现了WebSecurityConfigurer的bean中，或者（简单起见）扩展WebSecurityConfigurerAdapter
007、用户数据通常会存储在关系型数据库中，并通过JDBC进行访问。为了配置Spring Security使用以JDBC为支撑的用户存储，我们可以使用jdbcAuthentication()方法
008、Spring Security的加密模块包括了三个这样的实现：BCryptPasswordEncoder、NoOpPasswordEncoder和StandardPasswordEncoder。

第10章、通过Spring和JDBC征服数据库
001、Spring配置数据源的方式：通过JDBC驱动程序定义的数据源、通过JNDI查找的数据源、使用数据源连接池。
002、在开发或测试的情况下可以使用嵌入式的数据源（embedded database）
003、借助Spring的profile特性能够在运行时选择数据源
004、Spring为JDBC提供了三个模板类：JdbcTemplate（绝大多数用这个）、NamedParameterJdbcTemplate、SimpleJdbcTemplate


第11章、使用对象-关系映射持久化数据
001、Spring和Hibernate
002、如果你使用Hibernate 3.2或更高版本（直到Hibernate 4.0，但不包含这个版本）并且使用XML定义映射的话，那么你需要定义Spring的org.springframework.orm.hibernate3包中的LocalSessionFactoryBean
003、如果你更倾向于使用注解的方式来定义持久化，并且你还没有使用Hibernate 4的话，那么需要使用AnnotationSessionFactoryBean来代替LocalSessionFactoryBean
004、如果你使用Hibernate 4的话，那么就应该使用org.springframework.orm.hibernate4中的LocalSessionFactoryBean
002、应用程序管理类型的EntityManager是由EntityManagerFactory创建的，而后者是通过PersistenceProvider的createEntityManagerFactory()方法得到的。
003、容器管理类型的EntityManagerFactory是通过PersistenceProvider的createContainerEntityManagerFactory()方法获得的。
004、Spring提供了多个JPA厂商适配器：EclipseLinkJpaVendorAdapter、HibernateJpaVendorAdapter、OpenJpaVendorAdapter、TopLinkJpaVendorAdapter（在Spring 3.1版本中，已经将其废弃了）
005、可以在LocalContainerEntityManagerFactoryBean中通过packagesToScan属性设置需要扫描的包，这样就会在这个包查找带有@Entity注解的类。